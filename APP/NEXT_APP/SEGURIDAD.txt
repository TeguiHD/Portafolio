================================================================================
 üîê ARQUITECTURA DE SEGURIDAD - PORTAFOLIO NEXT.JS
================================================================================
 Versi√≥n: 2026.01.31 (v2)
 Autor: Sistema de Auditor√≠a
 Prop√≥sito: Documentar TODAS las medidas de ciberseguridad implementadas
================================================================================

Este documento explica en t√©rminos simples CADA medida de seguridad implementada
en el proyecto, para que puedas entender la l√≥gica y aplicarla a futuros 
proyectos.

================================================================================
 üìë √çNDICE
================================================================================

1. AUTENTICACI√ìN Y SESIONES
2. AUTORIZACI√ìN Y PERMISOS (RBAC)
3. PROTECCI√ìN CONTRA ATAQUES WEB
4. CRIPTOGRAF√çA Y ENCRIPTACI√ìN
5. RATE LIMITING (L√çMITE DE SOLICITUDES)
6. AUDITOR√çA Y LOGGING
7. HONEYPOTS (TRAMPAS PARA HACKERS)
8. COOKIES SEGURAS
9. VALIDACI√ìN DE ENTRADA
10. HEADERS DE SEGURIDAD
11. RACE CONDITIONS (CONDICIONES DE CARRERA)  ‚Üê NUEVO
12. COMPARTIR ENLACES DE COTIZACI√ìN DE FORMA SEGURA  ‚Üê NUEVO
13. RESUMEN DE ARCHIVOS

================================================================================
 1. AUTENTICACI√ìN Y SESIONES
================================================================================

üìÅ Archivos: lib/auth.ts, lib/session-manager.ts, lib/mfa.ts


¬øQU√â ES?
--------
La autenticaci√≥n verifica que eres quien dices ser (login).
Las sesiones recuerdan que ya te autenticaste.


MEDIDAS IMPLEMENTADAS:
---------------------

a) CONTRASE√ëAS CON HASH (Argon2)
   - Las contrase√±as NUNCA se guardan como texto.
   - Se usa Argon2, el algoritmo GANADOR de la competencia de hashing.
   - Es resistente a ataques de GPU y ASIC.
   
   C√≥digo simple:
   ```
   import { hash, verify } from "argon2"
   
   // Guardar contrase√±a
   const hashPassword = await hash(password)
   
   // Verificar contrase√±a
   const isValid = await verify(hashPassword, inputPassword)
   ```

b) BLOQUEO POR INTENTOS FALLIDOS
   - Despu√©s de 5 intentos fallidos, la cuenta se bloquea 15 minutos.
   - Evita ataques de "fuerza bruta" (probar miles de contrase√±as).
   
   L√≥gica:
   ```
   if (failedAttempts >= 5) {
       lockedUntil = ahora + 15 minutos
   }
   ```

c) AUTENTICACI√ìN DE DOS FACTORES (MFA/2FA)
   - Usa TOTP (Time-based One-Time Password).
   - Compatible con Google Authenticator, Authy, etc.
   - Genera c√≥digos de 6 d√≠gitos que cambian cada 30 segundos.
   - Incluye c√≥digos de recuperaci√≥n (8 c√≥digos de emergencia).

d) GESTI√ìN DE SESIONES
   - Cada sesi√≥n se guarda en base de datos con:
     * IP del usuario
     * Navegador y dispositivo
     * Fecha de √∫ltima actividad
   - Detecta sesiones concurrentes (alguien m√°s en tu cuenta).
   - Permite revocar sesiones individualmente.

e) TOKENS JWT FIRMADOS
   - Los tokens usan HMAC-SHA256 para firmar.
   - Incluyen:
     * ID de usuario
     * Fecha de expiraci√≥n
     * Nonce aleatorio (previene reutilizaci√≥n)
   - Son verificables sin acceder a base de datos.


================================================================================
 2. AUTORIZACI√ìN Y PERMISOS (RBAC)
================================================================================

üìÅ Archivos: lib/permissions.ts, lib/permission-check.ts


¬øQU√â ES?
--------
La autorizaci√≥n verifica QU√â puedes hacer despu√©s de autenticarte.
RBAC = Role-Based Access Control (acceso basado en roles).


ARQUITECTURA DE PERMISOS:
------------------------

ROLES:
  USER       ‚Üí Usuario b√°sico, solo lee
  MODERATOR  ‚Üí Puede moderar contenido
  ADMIN      ‚Üí Puede gestionar usuarios y configuraci√≥n
  SUPERADMIN ‚Üí Dios, puede todo

PERMISOS GRANULARES:
  quotations.view    ‚Üí Ver cotizaciones
  quotations.create  ‚Üí Crear cotizaciones
  quotations.edit    ‚Üí Editar cotizaciones
  quotations.delete  ‚Üí Eliminar cotizaciones
  users.manage       ‚Üí Gestionar usuarios
  tools.manage       ‚Üí Gestionar herramientas

C√ìMO FUNCIONA:
```
// 1. Cada permiso tiene roles por defecto
{ 
  code: "quotations.edit",
  defaultRoles: ["SUPERADMIN", "ADMIN"]
}

// 2. Se pueden dar/quitar permisos individualmente
// Usuario X con rol USER pero CON permiso quotations.edit

// 3. La verificaci√≥n combina rol + excepciones
const hasAccess = await hasPermission(userId, userRole, "quotations.edit")
```


================================================================================
 3. PROTECCI√ìN CONTRA ATAQUES WEB
================================================================================

üìÅ Archivos: lib/security.ts, lib/quotation-sanitizer.ts, lib/honeypot.ts


A) XSS (Cross-Site Scripting)
-----------------------------

¬øQu√© es?
  Un atacante inyecta JavaScript malicioso en tu p√°gina.
  Ejemplo: En un comentario meten: <script>robar_cookies()</script>

Protecci√≥n:
  1. SANITIZACI√ìN DE ENTRADA
     Reemplaza caracteres peligrosos:
     ```
     < ‚Üí &lt;
     > ‚Üí &gt;
     " ‚Üí &quot;
     & ‚Üí &amp;
     ```
  
  2. USO DE DOMPurify
     Librer√≠a especializada que limpia HTML:
     ```
     import DOMPurify from "dompurify"
     const cleanHtml = DOMPurify.sanitize(dirtyHtml)
     ```

  3. CONTENT SECURITY POLICY (CSP)
     Header que dice al navegador qu√© scripts puede ejecutar:
     ```
     Content-Security-Policy: script-src 'self' https://trusted.com
     ```


B) SQL INJECTION
----------------

¬øQu√© es?
  Un atacante manipula consultas SQL a trav√©s de inputs.
  Ejemplo: username = "admin'; DROP TABLE users; --"

Protecci√≥n:
  1. USO DE PRISMA ORM
     - Prisma usa "prepared statements" autom√°ticamente.
     - Los par√°metros NUNCA se concatenan con el SQL.
     
     MAL (vulnerable):
     ```sql
     SELECT * FROM users WHERE email = '${email}'
     ```
     
     BIEN (Prisma lo hace as√≠):
     ```
     prisma.user.findUnique({ where: { email } })
     // Internamente: SELECT * FROM users WHERE email = $1
     ```


C) CSRF (Cross-Site Request Forgery)
------------------------------------

¬øQu√© es?
  Un atacante te hace hacer solicitudes sin tu consentimiento.
  Ejemplo: Imagen en otro sitio que hace DELETE /api/mi-cuenta

Protecci√≥n:
  1. COOKIES sameSite: "strict"
     La cookie SOLO se env√≠a si navegas directamente al sitio.
     No se env√≠a si vienes de otro sitio.
  
  2. VERIFICACI√ìN DE ORIGIN
     El servidor verifica que la solicitud venga del mismo dominio.


D) PATH TRAVERSAL
-----------------

¬øQu√© es?
  Intentar acceder a archivos fuera del directorio permitido.
  Ejemplo: /api/file?path=../../../etc/passwd

Protecci√≥n:
  Validar y sanitizar todas las rutas de archivo.
  Usar rutas absolutas y verificar que est√©n dentro del directorio permitido.


================================================================================
 4. CRIPTOGRAF√çA Y ENCRIPTACI√ìN
================================================================================

üìÅ Archivos: lib/db-encryption.ts, lib/secure-token.ts, lib/mfa.ts


A) ENCRIPTACI√ìN DE BASE DE DATOS (AES-256-GCM)
----------------------------------------------

Para campos sensibles (emails, tel√©fonos, notas financieras):

```
ALGORITMO: AES-256-GCM
  - AES = Advanced Encryption Standard (est√°ndar mundial)
  - 256 = Longitud de llave en bits (muy seguro)
  - GCM = Galois/Counter Mode (incluye autenticaci√≥n)

PROCESO:
  1. Generar IV (Initialization Vector) aleatorio
  2. Derivar llave con HKDF (para diferentes campos)
  3. Encriptar con AES-256-GCM
  4. Guardar: {version, salt, iv, tag, data}

EJEMPLO:
  Antes: "juan@email.com"
  Despu√©s: "v1.abc123.xyz789.qwe456.encrypteddata..."
```

B) TOKENS CON FIRMA HMAC
------------------------

```
HMAC = Hash-based Message Authentication Code

C√ìMO FUNCIONA:
  1. Crear payload JSON (datos del token)
  2. Calcular HMAC-SHA256 del payload
  3. Token = base64(payload) + "." + base64(firma)

VERIFICACI√ìN:
  1. Separar payload y firma
  2. Recalcular HMAC del payload
  3. Comparar firmas (timing-safe)
  4. Si coinciden, el token es v√°lido
```

C) COMPARACI√ìN TIMING-SAFE
--------------------------

```
¬øPor qu√© importa?
  Si comparas strings normalmente:
  "abc" vs "axe" ‚Üí Se detiene en el 2do car√°cter (r√°pido)
  "abc" vs "abd" ‚Üí Se detiene en el 3er car√°cter (lento)
  
  Un atacante puede medir el tiempo y adivinar car√°cter por car√°cter.

SOLUCI√ìN:
  import { timingSafeEqual } from "crypto"
  
  // Siempre tarda lo mismo, sin importar d√≥nde difieren
  timingSafeEqual(Buffer.from(a), Buffer.from(b))
```


================================================================================
 5. RATE LIMITING (L√çMITE DE SOLICITUDES)
================================================================================

üìÅ Archivos: lib/redis.ts, lib/api-security.ts, lib/rate-limit.ts


¬øQU√â ES?
--------
Limitar cu√°ntas solicitudes puede hacer una IP/usuario en un tiempo.
Evita ataques de fuerza bruta y DoS.


IMPLEMENTACI√ìN:
--------------

```
REDIS (producci√≥n):
  - Usa algoritmo de "sliding window" (ventana deslizante).
  - Cada IP tiene un contador que expira.
  
  Key: rate:192.168.1.1:/api/login
  Value: 5 (solicitudes en los √∫ltimos 60 segundos)
  
  Si value >= l√≠mite ‚Üí BLOQUEADO

FALLBACK EN MEMORIA:
  - Para desarrollo sin Redis.
  - Usa Map en memoria.
  - ‚ö†Ô∏è No funciona en producci√≥n con m√∫ltiples servidores.

CONFIGURACI√ìN T√çPICA:
  Login:      5 intentos / 15 minutos
  API:       30 solicitudes / minuto
  Contacto:   5 mensajes / hora
```


================================================================================
 6. AUDITOR√çA Y LOGGING
================================================================================

üìÅ Archivos: lib/audit.ts, lib/security-logger.ts


A) AUDIT LOG (Registro de Auditor√≠a)
------------------------------------

```
GUARDA EN BASE DE DATOS:
  - Qui√©n hizo qu√©
  - Cu√°ndo
  - Desde d√≥nde (IP, navegador)
  - Resultado (√©xito/fallo)

EVENTOS REGISTRADOS:
  ‚úì Login exitoso/fallido
  ‚úì Cambios de contrase√±a
  ‚úì Cambios de permisos
  ‚úì CRUD de entidades importantes
  ‚úì Acceso a datos sensibles

EJEMPLO DE LOG:
  {
    action: "login.failed",
    userId: null,
    ipAddress: "192.168.1.100",
    metadata: { email: "x@y.com", reason: "invalid_password" },
    createdAt: "2026-01-31T10:00:00Z"
  }
```

B) SECURITY LOGGER (Eventos de Seguridad)
-----------------------------------------

```
THREAT SCORING (Puntuaci√≥n de Amenaza):
  Cada evento suma puntos seg√∫n severidad:
  
  LOW:      +5 puntos
  MEDIUM:   +15 puntos
  HIGH:     +30 puntos
  CRITICAL: +50 puntos
  
  Si IP supera 50 puntos ‚Üí BLOQUEADA

EVENTOS DETECTADOS:
  - Intentos de inyecci√≥n SQL
  - Patrones XSS
  - Escaneo de vulnerabilidades
  - Acceso a rutas sospechosas
  - Firmas de bots maliciosos

INFORMACI√ìN ENRIQUECIDA:
  - Sistema operativo
  - Navegador
  - Conteo de solicitudes
  - Intentos de bypass detectados
```


================================================================================
 7. HONEYPOTS (TRAMPAS PARA HACKERS)
================================================================================

üìÅ Archivos: lib/honeypot.ts


¬øQU√â ES?
--------
Rutas falsas que parecen vulnerables para atraer atacantes.
Cualquier acceso = atacante detectado = IP bloqueada.


RUTAS TRAMPA:
------------

```
/api/admin/backup    ‚Üí Parece un backup de base de datos
/api/config          ‚Üí Parece configuraci√≥n expuesta
/api/.env            ‚Üí Parece variables de entorno
/api/debug           ‚Üí Parece modo debug
/wp-admin            ‚Üí Parece WordPress
/phpmyadmin          ‚Üí Parece panel de base de datos
```

RESPUESTAS FALSAS:
-----------------

```
// Para /api/.env (trampa)
DATABASE_URL=postgres://fake:fake@localhost:5432/fake
APP_TOKEN=HONEYPOT_TRAP_DO_NOT_USE
TRAP_VALUE=honeypot-trap-detected

// Mientras tanto, se registra:
üçØ [HONEYPOT] Attack detected!
  IP: 192.168.1.50
  Path: /api/.env
  ‚Üí IP bloqueada permanentemente
```

PATRONES DETECTADOS:
-------------------

```
- Log4Shell (CVE-2021-44228): ${jndi:ldap://...}
- Spring4Shell: class.module.classLoader
- SQL Injection: UNION SELECT, sleep(), --+
- XSS: <script>, javascript:, onerror=
- Path Traversal: ../../../
- LFI/RFI: /etc/passwd, file://
- Webshells: c99, r57, shell
```


================================================================================
 8. COOKIES SEGURAS
================================================================================

üìÅ Aplicado en: actions.ts, middleware, auth


ATRIBUTOS DE SEGURIDAD:
----------------------

```javascript
cookies.set("session", token, {
    httpOnly: true,    // JavaScript NO puede leerla
    secure: true,      // Solo HTTPS (producci√≥n)
    sameSite: "strict",// Solo del mismo sitio
    path: "/admin",    // Solo para ciertas rutas
    maxAge: 86400      // Expira en 24 horas
})
```

EXPLICACI√ìN SIMPLE:

  httpOnly: true
    - El navegador la env√≠a, pero JavaScript no puede accederla.
    - Protege contra XSS que intente robar cookies.
    - MAL:  document.cookie ‚Üí "session=abc123"
    - BIEN: document.cookie ‚Üí "" (vac√≠o)

  secure: true
    - Solo se env√≠a por HTTPS.
    - Protege contra ataques man-in-the-middle.

  sameSite: "strict"
    - SOLO se env√≠a si navegas directamente al sitio.
    - Si vienes de otro sitio, NO se env√≠a.
    - Protege contra CSRF.
    
    Ejemplo:
      Usuario en evil.com con imagen que llama a tu API:
      <img src="https://tu-sitio.com/api/delete-account">
      ‚Üí Cookie NO se env√≠a ‚Üí Ataque fallido

  path: "/admin"
    - Cookie solo existe para rutas que empiecen con /admin.
    - /api/public ‚Üí No tiene la cookie.
    - /admin/users ‚Üí S√≠ tiene la cookie.


================================================================================
 9. VALIDACI√ìN DE ENTRADA
================================================================================

üìÅ Archivos: lib/security.ts, lib/api-security.ts


PRINCIPIO: NUNCA CONF√çES EN EL USUARIO

```
TODO input debe validarse:
  1. Tipo correcto (string, number, etc.)
  2. Longitud m√°xima (previene DoS)
  3. Formato correcto (email, tel√©fono)
  4. Caracteres permitidos (sanitizaci√≥n)
```

EJEMPLOS:

```javascript
// Validar email
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
if (!emailRegex.test(email)) throw new Error("Email inv√°lido")

// Validar contrase√±a fuerte
if (password.length < 12) error("M√≠nimo 12 caracteres")
if (!/[A-Z]/.test(password)) error("Falta may√∫scula")
if (!/[0-9]/.test(password)) error("Falta n√∫mero")
if (!/[!@#$%]/.test(password)) error("Falta s√≠mbolo")

// Limitar longitud (previene DoS)
const CV_LIMITS = {
    name: 100,
    email: 254,
    description: 2000
}
const safeName = input.slice(0, CV_LIMITS.name)
```

SANITIZACI√ìN API:
----------------

```javascript
// En cada endpoint API
const security = await secureApiEndpoint(request, {
    requireAuth: true,
    requiredPermission: "users.manage",
    maxBodySize: 1024 * 100,  // M√°ximo 100KB
    rateLimit: { limit: 30, windowMs: 60000 },
    sensitiveFields: ["password", "ssn"],  // No loguear estos
    checkThreatScore: true,    // Verificar IP sospechosa
    auditAccess: true          // Registrar acceso
})
```


================================================================================
 10. HEADERS DE SEGURIDAD
================================================================================

üìÅ Configurado en: next.config.js, middleware


HEADERS IMPORTANTES:

```
Content-Security-Policy (CSP):
  - Controla qu√© recursos puede cargar la p√°gina.
  - Previene XSS y clickjacking.
  
  Ejemplo:
    script-src 'self' https://cdn.trusted.com
    (Solo ejecuta scripts propios o del CDN confiable)

X-Frame-Options: DENY
  - Previene que tu sitio sea embebido en iframes.
  - Protege contra clickjacking.

X-Content-Type-Options: nosniff
  - El navegador NO intenta "adivinar" el tipo de archivo.
  - Previene ataques MIME-type confusion.

Strict-Transport-Security (HSTS):
  - Fuerza HTTPS por 1 a√±o.
  - Incluye subdominios.
  
  Ejemplo:
    max-age=31536000; includeSubDomains

Referrer-Policy: strict-origin-when-cross-origin
  - Controla qu√© informaci√≥n se env√≠a al navegar.
  - No expone URLs internas a sitios externos.
```


================================================================================
 11. RACE CONDITIONS (CONDICIONES DE CARRERA)
================================================================================

üìÅ Archivos: lib/rate-limit.ts, api/finance/transactions/route.ts, 
            api/quotations/route.ts

üîó Fuentes: OWASP Testing Guide, PortSwigger Research
            https://portswigger.net/research/smashing-the-state-machine


¬øQU√â ES?
--------
Una race condition ocurre cuando m√∫ltiples operaciones concurrentes acceden
a recursos compartidos sin sincronizaci√≥n adecuada, causando:

- L√≠mite de solicitudes evadido
- Transacciones duplicadas
- Saldos incorrectos
- Duplicaci√≥n de folios/IDs √∫nicos


PATR√ìN VULNERABLE: TOCTOU (Time-of-Check-to-Time-of-Use)
--------------------------------------------------------

```
VULNERABLE (check-then-increment):

  Tiempo    Usuario A                    Usuario B
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    T1      Lee contador: 4               
    T2                                   Lee contador: 4
    T3      ¬ø4 < 5? S√≠, permitido
    T4                                   ¬ø4 < 5? S√≠, permitido
    T5      Escribe: contador = 5
    T6                                   Escribe: contador = 5
  
  RESULTADO: Ambos pasan, ¬°l√≠mite de 5 se evadi√≥!
```


A) PROTECCI√ìN: TRANSACCIONES AT√ìMICAS (Prisma)
----------------------------------------------

```typescript
// MAL - Separado (vulnerable)
const transaction = await prisma.transaction.create({...});
await updateAccountBalance(accountId, amount);  // ‚Üê Race condition

// BIEN - At√≥mico (seguro)
const result = await prisma.$transaction(async (tx) => {
    const transaction = await tx.transaction.create({...});
    await tx.financeAccount.update({
        where: { id: accountId },
        data: { currentBalance: { increment: amount } }  // ‚Üê At√≥mico
    });
    return transaction;
});
```


B) PROTECCI√ìN: RATE LIMITING AT√ìMICO
------------------------------------

```typescript
// MAL - Check-then-increment (vulnerable)
const existing = await prisma.rateLimitEntry.findUnique({...});
if (existing.count >= RATE_LIMIT) return blocked;
await prisma.rateLimitEntry.update({count: existing.count + 1}); // ‚Üê Race

// BIEN - Transacci√≥n serializable (seguro)
const result = await prisma.$transaction(async (tx) => {
    const existing = await tx.rateLimitEntry.findUnique({...});
    if (existing?.count >= config.limit) {
        return { allowed: false, remaining: 0 };
    }
    // Check e increment en la MISMA transacci√≥n
    await tx.rateLimitEntry.update({
        where: { identifier },
        data: { count: { increment: 1 } }
    });
    return { allowed: true, remaining: config.limit - existing.count - 1 };
}, {
    isolationLevel: Prisma.TransactionIsolationLevel.Serializable  // ‚Üê Clave
});
```


C) PROTECCI√ìN: GENERACI√ìN DE FOLIO AT√ìMICA
------------------------------------------

```typescript
// MAL - Count-then-create (vulnerable a folios duplicados)
const count = await prisma.quotation.count({...});
const folio = `WEB-2026-${String(count + 1).padStart(3, "0")}`;
await prisma.quotation.create({ data: { folio, ... } });

// BIEN - FOR UPDATE lock + retry (seguro)
const quotation = await prisma.$transaction(async (tx) => {
    // Bloquea las filas mientras se lee
    const result = await tx.$queryRaw`
        SELECT COUNT(*) as count FROM "Quotation" 
        WHERE "folio" LIKE ${prefix + '%'}
        FOR UPDATE
    `;
    const count = Number(result[0]?.count || 0);
    const folio = `${prefix}-${String(count + 1).padStart(3, "0")}`;
    
    return await tx.quotation.create({ data: { folio, ... } });
});

// Adem√°s: retry logic para violaciones de constraint √∫nico
```


D) PROTECCI√ìN: UPSERT AT√ìMICO (Product Catalog)
-----------------------------------------------

```typescript
// MAL - Find-then-update (lost updates con concurrencia)
const product = await prisma.product.findUnique({...});
const newAvg = (product.avgPrice * product.count + price) / (product.count + 1);
await prisma.product.update({ data: { avgPrice: newAvg } }); // ‚Üê Lost update

// BIEN - INSERT ON CONFLICT (at√≥mico en PostgreSQL)
await prisma.$executeRaw`
    INSERT INTO "Product" (...) VALUES (...)
    ON CONFLICT ("userId", "normalizedName") DO UPDATE SET
        "avgPrice" = (("Product"."avgPrice" * "Product"."priceCount") + ${price}) 
                     / ("Product"."priceCount" + 1),
        "priceCount" = "Product"."priceCount" + 1,
        "minPrice" = LEAST("Product"."minPrice", ${price}),
        "maxPrice" = GREATEST("Product"."maxPrice", ${price})
`;
```


RESUMEN DE PATRONES SEGUROS:
---------------------------

  PATR√ìN VULNERABLE           | SOLUCI√ìN SEGURA
  ----------------------------|------------------------------------------
  Read ‚Üí Calculate ‚Üí Write    | prisma.$transaction con increment
  Check ‚Üí Act                 | Transacci√≥n con isolationLevel Serializable
  Count ‚Üí Create              | FOR UPDATE lock + unique constraint + retry
  Find ‚Üí Update               | INSERT ON CONFLICT DO UPDATE


================================================================================
 12. COMPARTIR ENLACES DE COTIZACI√ìN DE FORMA SEGURA
================================================================================

üìÅ Archivos: lib/secure-token.ts, services/quotation-access.ts,
            app/cotizacion/[clientSlug]/[quotationSlug]/


¬øQU√â ES?
--------
Permitir que clientes vean cotizaciones sin autenticarse, usando un link
seguro que expira y tiene registro de accesos.


MEDIDAS IMPLEMENTADAS:
---------------------

A) TOKENS FIRMADOS CON HMAC
   ```
   Token = base64(payload) + "." + base64(hmac_sha256(payload))
   
   Payload:
   - quotationId: ID de la cotizaci√≥n
   - expiresAt: Fecha de expiraci√≥n (7 d√≠as por defecto)
   - nonce: Valor aleatorio (unicidad)
   
   Verificaci√≥n:
   1. Separar payload y firma
   2. Recalcular HMAC del payload
   3. Comparar firmas (timing-safe para evitar timing attacks)
   4. Validar expiraci√≥n
   ```

B) REGISTRO DE ACCESOS
   ```
   Cada visita registra:
   - IP del visitante
   - User-Agent (navegador)
   - Timestamp
   - Token usado
   
   Permite detectar:
   - Accesos sospechosos desde m√∫ltiples ubicaciones
   - Ataques de fuerza bruta al token
   - Uso despu√©s de expiraci√≥n
   ```

C) COOKIES DE SESI√ìN SEGURAS
   ```javascript
   cookies.set("quotation_access", token, {
       httpOnly: true,
       secure: true,
       sameSite: "strict",
       path: "/cotizacion",
       maxAge: 7 * 24 * 60 * 60  // 7 d√≠as
   });
   ```

D) SANITIZACI√ìN DE CONTENIDO
   - Todo HTML en notas/descripciones pasa por DOMPurify
   - Previene XSS en contenido de cotizaciones
   - L√≠mites de longitud por campo

E) RATE LIMITING EN ACCESO
   - M√°ximo 100 accesos por IP/hora
   - Previene enumeraci√≥n de tokens


================================================================================
 13. RESUMEN DE ARCHIVOS DE SEGURIDAD
================================================================================

üìÅ Carpeta: /src/lib/

ARCHIVO                    | PROP√ìSITO
---------------------------|--------------------------------------------------
security.ts               | Sanitizaci√≥n XSS, validaci√≥n de passwords
security.server.ts        | Utilidades del lado servidor
api-security.ts           | Middleware completo para APIs
db-encryption.ts          | Encriptaci√≥n AES-256-GCM para BD
secure-token.ts           | Tokens HMAC firmados para enlaces compartidos
session-manager.ts        | Gesti√≥n de sesiones de usuario
mfa.ts                    | Autenticaci√≥n de dos factores (TOTP)
honeypot.ts               | Trampas para detectar atacantes
audit.ts                  | Registro de auditor√≠a en BD
security-logger.ts        | Logging de eventos de seguridad
redis.ts                  | Rate limiting con Redis
rate-limit.ts             | Rate limiting at√≥mico (anti-race condition)
permission-check.ts       | Verificaci√≥n de permisos
permissions.ts            | Definici√≥n de permisos RBAC
quotation-sanitizer.ts    | Sanitizaci√≥n de HTML para cotizaciones
nonce.ts                  | Generaci√≥n de nonces para CSP


================================================================================
 üéì PRINCIPIOS CLAVE PARA TUS FUTUROS PROYECTOS
================================================================================

1. DEFENSA EN PROFUNDIDAD
   No conf√≠es en una sola medida. M√∫ltiples capas de seguridad.

2. PRINCIPIO DE M√çNIMO PRIVILEGIO
   Solo da los permisos estrictamente necesarios.

3. FAIL SECURE
   Si algo falla, falla de manera segura (denegar en lugar de permitir).

4. NUNCA CONF√çES EN EL INPUT
   Todo dato del usuario es potencialmente malicioso.

5. LOGS Y AUDITOR√çA
   Si no lo registras, no puedes investigarlo despu√©s.

6. SECRETOS FUERA DEL C√ìDIGO
   Usa variables de entorno. Nunca comitees secretos.

7. ACTUALIZA DEPENDENCIAS
   Las vulnerabilidades se descubren constantemente.
   Usa npm audit, npm overrides para forzar versiones parchadas.

8. HTTPS SIEMPRE
   Sin excepciones. HTTP es inaceptable.

9. OPERACIONES AT√ìMICAS                                              ‚Üê NUEVO
   Usa transacciones de base de datos para evitar race conditions.
   Prefiere increment/decrement sobre read-modify-write.

10. TOKENS FIRMADOS Y CON EXPIRACI√ìN                                 ‚Üê NUEVO
    Nunca uses IDs predecibles. Siempre firma con HMAC y valida.


================================================================================
 üìã CHECKLIST DE SEGURIDAD PARA NUEVAS FEATURES
================================================================================

Antes de desplegar cualquier nueva funcionalidad, verifica:

[ ] ¬øLos inputs est√°n validados y sanitizados?
[ ] ¬øLas operaciones de BD usan transacciones at√≥micas?
[ ] ¬øHay rate limiting apropiado?
[ ] ¬øLos tokens/links est√°n firmados y expiran?
[ ] ¬øSe registran los accesos/cambios en audit log?
[ ] ¬øLos permisos est√°n verificados?
[ ] ¬øLas cookies tienen httpOnly, secure, sameSite?
[ ] ¬ønpm audit muestra 0 vulnerabilidades?
[ ] ¬øLos headers de seguridad est√°n configurados?
[ ] ¬øHay honeypots en rutas sensibles?


================================================================================
 FIN DEL DOCUMENTO
================================================================================